// Copyright (c) 2017 Computer Vision Center (CVC) at the Universitat Autonoma
// de Barcelona (UAB).
//
// This work is licensed under the terms of the MIT license.
// For a copy, see <https://opensource.org/licenses/MIT>.

#pragma once

#include "carla/Memory.h"
#include "carla/sensor/RawData.h"

#include <cstdint>
#include <cstring>

namespace carla {
namespace sensor {

  class SensorData;

namespace s11n {

  /// Serializes image buffers generated by GPU-Lidar sensors.
  class GPULidarSerializer {
  public:

#pragma pack(push, 1)
    struct GPULidarHeader {
      uint32_t max_horizontal_points;
      uint32_t channels;
      uint32_t current_horizontal_points;
      float fov;
      float horizontal_angle;
    };
#pragma pack(pop)

    constexpr static auto header_offset = sizeof(GPULidarHeader);

    static const GPULidarHeader &DeserializeHeader(const RawData &data) {
      return *reinterpret_cast<const GPULidarHeader *>(data.begin());
    }

    template <typename Sensor>
    static Buffer Serialize(
        const Sensor &sensor,
        Buffer bitmap,
        uint32_t current_horizontal_points,
        float horizontal_angle);

    static SharedPtr<SensorData> Deserialize(RawData data);

  };

  template <typename Sensor>
  inline Buffer GPULidarSerializer::Serialize(
      const Sensor &sensor,
      Buffer bitmap,
      uint32_t current_horizontal_points,
      float horizontal_angle) {

    DEBUG_ASSERT(bitmap.size() > sizeof(GPULidarHeader));
    GPULidarHeader header = {
      sensor.GetMaxHorizontalPoints(),
      sensor.GetChannels(),
      current_horizontal_points,
      sensor.GetFov(),
      horizontal_angle,
    };
    std::memcpy(bitmap.data(), reinterpret_cast<const void *>(&header), sizeof(header));
    return bitmap;
  }

} // namespace s11n
} // namespace sensor
} // namespace carla
